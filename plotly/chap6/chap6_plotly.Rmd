---
title : 비교(Compare), 차이(difference)와 구성(Composition)의 시각화
output:
  officedown::rdocx_document:
    reference_docx: bookdown.docx
    plots:
      style: Normal
      align: center
      fig.lp: 'fig:'
      topcaption: false
      caption:
        style: Image Caption
        pre: '실행결과 6-'
        sep: ''
        tnd: 0
        tns: '-'
        fp_text: !expr officer::fp_text_lite(bold = TRUE)
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, fig.width = 6.5, dpi = 130)
library(showtext)
showtext_auto()
library(tidyverse)
library(readxl)
library(patchwork)
library(plotly)

```

```{r include=FALSE, message = FALSE, warning = FALSE}
df_취업률 <- read_excel('d:/R/data/2020년 학과별 고등교육기관 취업통계.xlsx', 
                     ## '학과별' 시트의 데이터를 불러오는데,
                     sheet = '학과별',
                     ## 앞의 13행을 제외하고
                     skip = 13, 
                     ## 첫번째 행은 열 이름으로 설정
                     col_names = TRUE, 
                     ## 열의 타입을 설정, 처음 9개는 문자형으로 다음 79개는 수치형으로 설정
                     col_types = c(rep('text', 9), rep('numeric', 79)))

## df_취업률에서 첫번째부터 9번째까지의 열과 '계'로 끝나는 열을 선택하여 다시 df_취업률에 저장
df_취업률 <- df_취업률 |> 
  select(1:9, ends_with('계'), '입대자')


## 랜덤 샘플을 위한 시드 설정
set.seed(123)

## df_취업률에서 졸업자가 500명 이하인 학과 2000개 샘플링
df_취업률_2000 <- df_취업률 |> 
  filter(졸업자_계 < 500) |> 
  sample_n(2000)

## 열 이름을 적절히 설정
names(df_취업률_2000)[10:12] <- c('졸업자수', '취업률', '취업자수')
names(df_취업률)[10:12] <- c('졸업자수', '취업률', '취업자수')


library(readr)
library(lubridate)

# covid19_df <- read_csv(file = "D:/R/data/owid-covid-data.csv",
#                             col_types = cols(Date = col_date(format = "%Y-%m-%d")
#                                              )
#                             )

df_covid19 <- read_csv(file = "https://covid.ourworldindata.org/data/owid-covid-data.csv",
                            col_types = cols(Date = col_date(format = "%Y-%m-%d")
                                             )
                            )
df_covid19_100 <- df_covid19 |> 
  filter(iso_code %in% c('KOR', 'OWID_ASI', 'OWID_EUR', 'OWID_OCE', 'OWID_NAM', 'OWID_SAM', 'OWID_AFR')) |>
  filter(date >= max(date) - 100) |>
  mutate(location = case_when(
    location == 'South Korea' ~ '한국', 
    location == 'Asia' ~ '아시아', 
    location == 'Europe' ~ '유럽', 
    location == 'Oceania' ~ '오세아니아', 
    location == 'North America' ~ '북미', 
    location == 'South America' ~ '남미', 
    location == 'Africa' ~ '아프리카')) |>
  mutate(location = fct_relevel(location, '한국', '아시아', '유럽', '북미', '남미', '아프리카', '오세아니아')) |>
  arrange(date)

df_covid19_100_wide <- df_covid19_100 |>
  select(date, location, new_cases, people_fully_vaccinated_per_hundred) |>
  rename('date' = 'date', '확진자' = 'new_cases', '백신접종완료자' = 'people_fully_vaccinated_per_hundred') |>
  pivot_wider(id_cols = date, names_from = location, 
              values_from = c('확진자', '백신접종완료자')) |>
  arrange(date)

df_covid19_stat <- df_covid19 |> 
  group_by(iso_code, continent, location) |>
  summarise(인구수 = max(population, na.rm = T), 
            인당GDP = max(gdp_per_capita, na.rm = T),
            전체확진자수 = sum(new_cases, na.rm = T),
            전체사망자수 = sum(new_deaths, na.rm = T), 
            십만명당중환자실 = last(icu_patients_per_million),
            재생산지수 = last(reproduction_rate),
            봉쇄지수 = max(stringency_index), 
            전체검사자수 = max(total_tests, na.rm = T), 
            신규검사자수 = sum(new_tests, na.rm = T),
            전체백신접종자수 = max(total_vaccinations, na.rm = T),
            백신접종자완료자수 = max(people_fully_vaccinated, na.rm = T),
            부스터접종자수 = max(total_boosters, na.rm = T),
            인구백명당백신접종완료률 = max(people_fully_vaccinated_per_hundred, na.rm = T),
            인구백명당부스터접종자수 = max(total_boosters_per_hundred, na.rm = T)
            ) |> 
    ungroup() |>
    mutate(십만명당사망자수 = round(전체사망자수 / 인구수 *100000, 5),
           백신접종완료률 = 백신접종자완료자수 / 인구수)

margins <- list(t = 50, b = 25, l = 25, r = 25)

```

# 비교의 시각화

비교와 분포의 시각화는 데이터를 구성하는 특정 변수의 변량에 따라 데이터 값들간의 순서를 비교하거나 데이터의 구성 비율에 대한  시각화이다. 이 종류의 시각화는 다른 시각화와 다른 두가지 특징이 있다.

첫번째 특징은 시각화 그래프 내에서 한번 더 통계처리가 필요하다는 특성을 가진다. 보통 비교의 시각화는 데이터에 값에 따라 시각화 한 후 그 값들을 다시 정렬함으로써 시각화를 완성하게 된다. 따라서 데이터 시각화 이전이나 이후에  시각화 대상 데이터나 시각화 객체 에서 정렬과 같은 통계 처리가 한번 더 일어나게 된다.

두번째 특징은 그 관심의 대상이 데이터 자체의 값 보다는 비교되는 대상 내에서의 상대적 위치에 더 쏠려있다는 점이다. 비교되는 대상 중에 가장 값이 크거나 작은 변량이 무엇인지에 관심이 있는 시각화이다. 비교되는 대상들의 상대적 위치가 명확하게 구분되어야 하기 때문에 비교되는 대상들이 명확하게 구분되어야 하고 이 대상들을 명확하게 구분하기 위해 비교를 위한 변수는 이산형 변수를 사용하는 것이 일반적이다.

비교의 시각화는 막대 그래프가 많이 사용되는데 순위 막대 그래프, 롤리팝 그래프, 도트 그래프 등을 많이 사용한다. 

## 백신 접종률 top 10 국가는? - 순위 막대 그래프

------------------------------------------------------------------------

앞서 설명한 바와 같이 비교를 위한 시각화는 특정한 이산형 변수에 의한 수치형 변수를 정렬한 후에 가장 높은 순서부터 혹은 가장 낮은 순서부터 시각화하는 것을 말한다. 이 비교률 위한 시각화로 가장 많이 사용되는 시각화가 막대 그래프이다. `plotly`로 막대 그래프를 만들기 위해서는 막대 trace를 추가함으로써 그릴 수 있다. 비교에 사용되는 변수의 변량이 많지 않은 경우는 X축에 이산형 변수를 매핑하고 Y축에 비교하기 위한 수치 변수를 매핑하지만 비교에 사용되는 변수의 변량이 많은 경우는 Y축에 이산형 변수를 매핑하고 X축에 비교를 위한 변수를 매핑하여 아래쪽으로 수형으로 막대가 그려지는 수평형 막대 그래프를 사용한다. 

코로나19 데이터 셋에서 인구 100명당 완전 백신 접종자의 수가 가장 많은 10개의 국가를 시각화하기 위해서는 먼저 인구 100명당 완전 백신 접종자를 내림차순으로 정렬하고 이중 상위 10개국에 대해 시각화를 그려준다. `plotly`에서는 자체적으로 데이터를 정렬하는 기능을 제공하지 않는다. 따라서 정렬해야하는 데이터를 `reorder()`를 사용하여 매핑해줌으로써 정렬이 가능하다. 여기서 인구수가 너무 적은 국가는 백신접종률에 의미가 떨어지기 때문에 인구수가 천만명 이상의 국가를 대상으로 하여 백신접종률이 가장 높은 10개 국가를 시각화하는 코드는 다음과 같다. 

```{r fig.cap='데이터가 정렬된 막대그래프', eval=FALSE}
vaccine_top10 <- covid19_stat |>
  filter(인구수 > 10000000) |>
  top_n(10, 인구백명당백신접종완료률)

vaccine_top10 |> 
  plot_ly() |>
  add_trace(type = 'bar', 
            x = ~reorder(location, 인구백명당백신접종완료률, desc), 
            y = ~인구백명당백신접종완료률,
            color = ~continent, text = ~인구백명당백신접종완료률, 
            textposition = 'outside', texttemplate = '%{text}%', 
            textfont = list(color = 'black')) |>
  layout(title = '완전 백신 접종률 상위 top 10 국가', 
         xaxis = list(title = '국가명'), 
         yaxis = list(title = '백신접종완료율', 
                      ticksuffix = '%'), 
         margin = margins)

```

```{r fig.cap='데이터가 정렬된 막대그래프', echo=FALSE}
vaccine_top10 <- df_covid19_stat |>
  filter(인구수 > 10000000) |>
  top_n(10, 인구백명당백신접종완료률)

vaccine_top10 |> 
  plot_ly() |>
  add_trace(type = 'bar', 
            x = ~reorder(location, 인구백명당백신접종완료률, desc), y = ~인구백명당백신접종완료률,
            color = ~continent, colors = RColorBrewer::brewer.pal(6, 'Blues')[6:2], 
            text = ~인구백명당백신접종완료률, textposition = 'outside', texttemplate = '%{text}%', 
            textfont = list(color = 'black')
            ) |>
  layout(title = '완전 백신 접종률 상위 top 10 국가', 
         xaxis = list(title = '국가명'), 
         yaxis = list(title = '백신접종완료율', 
                      ticksuffix = '%'), 
         margin = margins)

```
앞의 백신 접종률 상위 top 10 국가를 보면 가장 백신 접종률이 높은 국가는 포르투갈로 92.6%이고, 우리나라는 전세계에서 4번째로 86.74%를 보이고 있다. 대륙별로 보자면 코로나19에 매우 피해가 컸던 유럽 국가에서는 포르투갈만과 스페인이 top 10에 포함되어 있고 아시아 국가가 가장 많은 3개 국가가 포함되었다. 남미가 2개국, 북미가 2개국, 오세아니아에서 1개국이 포함되었다. 아프리카 대륙의 국가는 한 나라도  포함되지 못한 것으로 나타난다.   

## 대륙별로 top 5 은? – 수평 막대 그래프

------------------------------------------------------------------------

앞서 살펴본 전세계 국가 중 백신 접종률 top 10은 백신 접종의 전체 현황은 살펴볼 수 있지만 각 대륙별 현황은 알아보기 어렵다. 이렇게 비교가 필요한 그룹간의 데이터를 비교하기 위해서는 각 그룹별로 상위 혹은 하위 데이터를 먼저 전처리 한 후 이 데이터를 사용해 시각화하는 방법을 사용해야 한다. 이번에는 각 대륙별 백신 접종률 top 5를 비교해보자. 

이를 위해서는 먼저 데이터를 전처리해야 한다. 각 대륙별로 그룹화하여 이 그룹별로 top 5를 산출해준다. 이 시각화는 앞선 시각화와는 몇 가지 차이가 있는데  가장 큰 차이는 수평 막대 그래프라는 점이다. 각 대륙별 top 5를 산출하면 6 대륙의 5개 국가이기 때문에 30개 국가가 산출되게 된다.  하재만 앞서와 같이 인구수가 너무 작은 국가를 제외하다보니 오세아니아 대륙은 1개 국가만이 필터링되어 총 26개국이 나오게 된다.  이렇게 많은 막대를 표현하기에는 좌우 폭은 너무 좁다. 따라서 이 시각화는 수평 막대 그래프로 표현하는 것이 효과적이다. 

또 하나의 차이는 각 대륙별로 그룹화하기 위해 하나의 추가적 열을 생성하였다. `plotly`에서는 두 개의 열에 대한 정렬을 사용할 수 없기 때문에 시각화할 순서를 미리 정해주는 순차 번호가 기록되는 열이다. 이 번호를 사용하여 국가를 정렬함으로써 대륙별 백신 접종률의 상위 top 5 국가들에 대한 시각화가 완성된다. 이 순차 번호 열을 Y축에 매핑했기 때문에 Y축에 표시되는 문자열을 설정하기 위해 `ticktext`와 `tickvals`를 설정하였다. 

```{r eval = FALSE}
vaccine_top5_by_continent <- covid19_stat |>
  filter(인구수 > 10000000, !is.na(continent)) |>
  group_by(continent) |>
  top_n(5, 인구백명당백신접종완료률) |>
  arrange(continent, desc(인구백명당백신접종완료률)) |>
  ungroup() |>
  mutate(seq = as.factor(seq(1:n())))

vaccine_top5_by_continent |> 
  plot_ly() |>
  add_trace(type = 'bar', 
            y = ~seq, x = ~인구백명당백신접종완료률,
            color = ~continent, 
            text = ~인구백명당백신접종완료률, textposition = 'outside', texttemplate = '%{text}%', 
            textfont = list(color = 'black'), 
            orientation = 'v'
            ) |>
  layout(barmode = 'group', title = '완전 백신 접종률 상위 top 10 국가', 
         xaxis = list(title = '백신접종완료율', 
                      ticksuffix = '%', range = c(0, 105)), 
         yaxis = list(title = '', autorange = 'reversed', 
                      tickvals = ~seq,
                      ticktext = ~location), 
         margin = margins)
```

```{r echo = FALSE}
vaccine_top5_by_continent <- df_covid19_stat |>
  filter(인구수 > 10000000, !is.na(continent)) |>
  group_by(continent) |>
  top_n(5, 인구백명당백신접종완료률) |>
  arrange(continent, desc(인구백명당백신접종완료률)) |>
  ungroup() |>
  mutate(seq = as.factor(seq(1:n())))


vaccine_top5_by_continent |> 
  plot_ly() |>
  add_trace(type = 'bar', 
            y = ~seq, x = ~인구백명당백신접종완료률,
            color = ~continent, colors = RColorBrewer::brewer.pal(6, 'Blues')[6:2], 
            text = ~인구백명당백신접종완료률, textposition = 'outside', texttemplate = '%{text}%', 
            textfont = list(color = 'black'), 
            orientation = 'v'
            ) |>
  layout(barmode = 'group', title = '완전 백신 접종률 상위 top 10 국가', 
         xaxis = list(title = '백신접종완료율', 
                      ticksuffix = '%', range = c(0, 105)), 
         yaxis = list(title = '', autorange = 'reversed', 
                      tickvals = ~seq,
                      ticktext = ~location), 
         margin = margins)
```

## 백신 접종률이 높은 국가의 사망률은? – 이중 축의 사용

```{r eval = FALSE}
vaccine_top10 |> 
  plot_ly() |>
  add_trace(type = 'bar',
            x = ~reorder(location, 인구백명당백신접종완료률, desc), y = ~인구백명당백신접종완료률,
            color = ~continent, text = ~인구백명당백신접종완료률, 
            textposition = 'outside', texttemplate = '%{text}%',
            textfont = list(color = 'black')) |>
  add_trace(type = 'scatter', mode = 'markers+text', 
            name = '사망자수', yaxis = "y2",
            x = ~reorder(location, 인구백명당백신접종완료률, desc), 
            y = ~십만명당사망자수, text = ~round(십만명당사망자수, 1), 
            textposition = 'top'
            )|>
  layout(title = '완전 백신 접종률 상위 top 10 국가', 
         xaxis = list(title = '국가명'), 
         yaxis = list(title = '백신접종완료율', 
                      ticksuffix = '%'), 
         yaxis2 = list(title = '인구10만명당 사망자수', 
                       side = "right", overlaying = "y",
                       range = c(0, 300), ticksuffix = '명'),
         margin = list(r = 100, t = 50), 
         legend = list(x = 1.1))

```

```{r echo = FALSE}
vaccine_top10 |> 
  plot_ly() |>
  add_trace(type = 'bar',
            x = ~reorder(location, 인구백명당백신접종완료률, desc), y = ~인구백명당백신접종완료률,
            color = ~continent, colors = RColorBrewer::brewer.pal(6, 'Blues')[6:2], 
            text = ~인구백명당백신접종완료률, textposition = 'outside', texttemplate = '%{text}%',
            textfont = list(color = 'black')) |>
  add_trace(type = 'scatter', mode = 'markers+text', 
            name = '사망자수', yaxis = "y2", color = I('black'), 
            x = ~reorder(location, 인구백명당백신접종완료률, desc), 
            y = ~십만명당사망자수, text = ~round(십만명당사망자수, 1), 
            textposition = 'top'
            )|>
  layout(title = '완전 백신 접종률 상위 top 10 국가', 
         xaxis = list(title = '국가명'), 
         yaxis = list(title = '백신접종완료율', 
                      ticksuffix = '%'), 
         yaxis2 = list(title = '인구10만명당 사망자수', 
                       side = "right", overlaying = "y",
                       range = c(0, 300), ticksuffix = '명'),
         margin = list(r = 100, t = 50), 
         legend = list(x = 1.1))

```

## 이중 축 사용

```{r eval = FALSE}
vaccine_top5_by_continent |> 
  plot_ly() |>
  add_trace(type = 'bar', 
            y = ~seq, x = ~인구백명당백신접종완료률,
            color = ~continent, 
            text = ~인구백명당백신접종완료률, textposition = 'outside', texttemplate = '%{text}%', 
            textfont = list(color = 'black'), 
            orientation = 'v'
            ) |>
  add_trace(type = 'scatter', mode = 'markers+text', 
            name = '사망자수', xaxis = "x2",
            y = ~seq, x = ~십만명당사망자수, color = I('black'),
            text = ~round(십만명당사망자수, 1), 
            textposition = 'right'
            )|>
  layout(barmode = 'group', 
         title = list(text = '완전 백신 접종률 상위 top 10 국가', 
                      y = 0.97, yref = 'container'), 
         xaxis = list(title = '백신접종완료율', range = c(0, 105), 
                      ticksuffix = '%'), 
         yaxis = list(title = '', autorange = 'reversed', 
                      tickvals = ~seq,
                      ticktext = ~location), 
         xaxis2 = list(title = list(text = '인구10만명당 사망자수', 
                                    standoff = 1), 
                       side = "top",
                       overlaying = "x",
                       range = c(0, 700), 
                      ticksuffix = '명'),
         margin = list(r = 100, t = 80), 
         size = list(height = 900)
         )
```

```{r echo = FALSE, fig.height = 7}
vaccine_top5_by_continent |> 
  plot_ly() |>
  add_trace(type = 'bar', 
            y = ~seq, x = ~인구백명당백신접종완료률,
            color = ~continent, colors = RColorBrewer::brewer.pal(6, 'Blues')[6:2], 
            text = ~인구백명당백신접종완료률, textposition = 'outside', texttemplate = '%{text}%', 
            textfont = list(color = 'black'), 
            orientation = 'v'
            ) |>
  add_trace(type = 'scatter', mode = 'markers+text', 
            name = '사망자수', xaxis = "x2",
            y = ~seq, x = ~십만명당사망자수, color = I('black'),
            text = ~round(십만명당사망자수, 1), 
            textposition = 'right'
            )|>
  layout(barmode = 'group', 
         title = list(text = '완전 백신 접종률 상위 top 10 국가', 
                      y = 0.97, yref = 'container'), 
         xaxis = list(title = '백신접종완료율', range = c(0, 105), 
                      ticksuffix = '%'), 
         yaxis = list(title = '', autorange = 'reversed', 
                      tickvals = ~seq,
                      ticktext = ~location), 
         xaxis2 = list(title = list(text = '인구10만명당 사망자수', 
                                    standoff = 1), 
                       side = "top",
                       overlaying = "x",
                       range = c(0, 700), 
                      ticksuffix = '명'),
          margin = list(r = 100, t = 80))

```

## 꼭 수직 막대를 사용해야 한다면 - 롤리팝 그래프

보통 우리가 보는 시각화는 인쇄물 형태이던 웹 브라우저 등의 모니터 화면으로 보던 좌우의 확장보다는 상하의 확장에 더 유연하다. 따라서 좌우로 표현되어야 하는 막대가 많이지면 앞서와 같이 상하 확정을 사용하는 수평형 막대 그래프를 사용한다. 하지만 한눈에 보이는 추세와 비교를 같이 표시하기 위해서는 막대의 너비가 다소 부담스러울 수 있다. 이런 경우 효과적으로 사용되는 시각화가 바로 롤리팝 그래프이다. 

롤리팝 그래프는 막대사탕의 상품명에서 유래된 그래프이다. 막대그래프와 유사하지만 그 표현을 막대가 아닌 막대사탕처럼 표현한다는데에서 유래했다. 원으로 표시된 데이터 점으로부터 축까지를 선으로 이어 데이터를 표현하는 방식의 그래프이다. 

`plotly`에서는 이 롤리팝 그래프를 trace 타입으로 제공하지는 않는다. 따라서 롤리팝 그래프를 그리기 위해서는 `scatter` trace의 `markers`와 `add_segments()`를 사용하여 그려야 한다. 이 과정에서 하나 주의해야 하는 것은 `markers` trace를 그리기 전에 `add_segements()`를 사용하여 선을 먼저 그려야 한다는 것이다. 만약 `markers`를 먼저 그리게 되면 점 안으로 선이 보이기 때문에 시각화가 보기 좋지 않다. 다음은 인구수 오백만명 이상의 아시아 지역 국가들의 백신 접종률을 롤리팝 그래프로 그린 코드이다.  

```{r echo = FALSE}
df_lolipop <- df_covid19_stat |>
  filter(인구수 > 5000000, continent == 'Asia') |>
  arrange(desc(인구백명당백신접종완료률))

df_lolipop |> 
  plot_ly() |>
  add_segments(x = ~reorder(location, desc(인구백명당백신접종완료률)), 
               xend = ~reorder(location, desc(인구백명당백신접종완료률)),
            y = ~인구백명당백신접종완료률, 
            yend = 0, color = I('gray')
            ) |>
  add_trace(type = 'scatter', mode = 'markers',  
            x = ~reorder(location, desc(인구백명당백신접종완료률)), 
            y = ~인구백명당백신접종완료률, color = I('darkblue')) |>
  layout(barmode = 'group', 
         title = list(text = '아시아 국가의 백신접종률', 
                      y = 0.97, yref = 'container'), 
         yaxis = list(title = '백신접종완료율', range = c(0, 105), 
                      ticksuffix = '%'), 
         xaxis = list(title = ''),
          margin = margins, showlegend = FALSE)
```

# 차이(difference)의 시각화

앞에서 설명한 비교의 시각화는 특정 변수의 변량값들을 서로 비교함으로써 상대적인 위치를 찾아내기 위한 시각화 방법이다. 하지만 동일 시각화 대상들의 시점이나 조건의 변화에 따른 변량 값의 차이를 확인하기 위해 사용하는 시각화 방법이 차이의 시각화이다. 시계열 그래프가 시간 변화의 조건에 따른 변량의 차이를 표현하는 좋은 예이기는 하지만 보통 차이의 시각화는 두 시점이나 두 조건의 차이를 보여주는 것이 효과적이다. 

## dumbell

덤벨(Dumbbell) 그래프는 동일한 변수의 두개의 값을 비교하기 위해 사용하는 차트이다. 일반적으로 양쪽 끝을 둥글게 만들고 그 사이를 선으로 연결하여 생긴 형태가 운동할때 쓰는 아령과 같이 생겨서 붙여진 이름이다.앞서 롤리팝 그래프와 같이 `plotly`는 덤벨 그래프를 위한 함수를 제공하지 않기 떄문에 `scatter` trace의 `markers`와 `add_segments()`를 사용하여 그려야 한다. 다음은 대륙별 인구수가 백만 이상의 국가 중에 십만명당 사망자수가 가장 작은 나라와 가장 큰 나라의 차이를 시각화하는 코드이다.   

```{r}
df_covid19_stat |>
  filter(!is.na(continent), 인구수 > 10000000) |>
  group_by(continent) |>
  summarise(min = min(십만명당사망자수), max = max(십만명당사망자수)) |>
  plot_ly() |>
  add_segments( 
            x = ~min, xend = ~max, y = ~continent, yend = ~continent,
            showlegend = FALSE, 
            color = I('gray')) |>
  add_trace(type = 'scatter', mode = 'markers+text', 
            x = ~min, y = ~continent, name = '최소', 
            text = ~round(min, 1), textposition = 'right bottom', 
            color = I('#1f77b4')) |>
  add_trace(type = 'scatter', mode = 'markers+text', 
            x = ~max, y = ~continent, name = '최대',  
            text = ~round(max, 1), textposition = 'left bottom', 
            color = I('darkblue')) |>
  layout(title = '대륙별 10만명당 사망자수 차이', 
         xaxis = list(title = '10만명당 사망자수'), 
         yaxis = list(title = '', autorange = 'reversed'), 
         margin = margins
         )
```

## 피라미드 그래프

```{r}
diff_kor <- 
  df_covid19_100 |> 
  filter(iso_code == 'KOR') |>
  ## date의 월 단위 열을 yearmonth에 저장
  mutate(date_by_week = lubridate::floor_date(date, "week"), 
         yearweekth =  paste0(lubridate::year(date_by_week), '년 ', 
                           lubridate::week(date_by_week), '주')) |> 
  ## iso_code, yearmonth로 그룹화
  group_by(iso_code, date_by_week, yearweekth) |>
  ## new_cases 합계 산출
  summarise(new_cases = sum(new_cases))

diff_kor |>
  plot_ly() |>
  add_trace(type = 'funnel', x = ~new_cases, y = ~date_by_week, 
            text = ~new_cases, texttemplate = '%{text:,.0f}') |>
  layout(title = '우리나라 주별 확진자수', 
    yaxis = list(title = '', 
                      tickvals = ~date_by_week, 
                      ticktext = ~yearweekth), 
    margin = margins)

```


# 구성의 시각화

구성의 시각화는 특정 데이터를 구성하는 각 부분의 비율을 시각화하는 것이다. 보통의 경우 비율이나 백분율을 통해 시각화하며 막대나 원을 세분화하여 그 비율을 보여준다. 여러개의 세부 범주로 나누어진 많은 범주들의 구성 비율을 나타내는데 비율 누적 막대 그래프가 많이 사용된다. 반면 단 하나의 범주에 대한 세부 범주의 구성 비율을 나타낼 때는 누적 막대 그래프 보다는 동그란 파이 차트나 도넛 차트로 나타낼 수 있다. 하지만 시각화 전문가들은 파이 차트나 도넛 차트는 권장하지 않는다. 사람의 시각으로는 파이 차트나 도넛 차트의 그 비율을 정확히 인지하기가 어렵기 때문이다. 이에 대한 대안으로 트리맵이나 와플 차트가 이용된다.

## 비율 막대 그래프

앞 장에서 `plotly`가 지원하는 막대 trace의 `barmode`는 stack, group, overlay, ralative의 네 가지가 있다고 설명하였다. 막대 그래프의 stack을 사용하면 구성의 시각화에 효과적으로 사용된다. 이를 비율 막대 그래프라고 하는데 막대 길이가 모두 1로 같게 그리고 막대를 구성하는 변량은 전체 대비 비율로 표현하는 막대 그래프이다. 따라서 전체 데이터 값의 비교가 불가능하고 단지 그 세부 분류의 비율만을 확인할 수 있다.

`ggplot2`에서는 비율 막대 그래프를 매개변수 설정만으로 간단히 만들수 있다. 그러나 `plotly`에서는 비율 누적 막대 그래프를  지원하지 않기 떄문에 비율 막대 그래프로 표현할 각 데이터들을 비율로 바꾸어 주는 전처리 과정이 필요하다.  전처리된 비율을 사용하여 `barmode = 'stack'`으로 막대 trace를 사용하면 비율 막대 그래프가 만들어진다. 그리고 만들어진 비율 막대 그래프에 비율을 표시하기 위해서는 비율을 주석으로 적절한 위치에 표시하여야 한다. 

다음은 전세계 국가들의 소득별로 그룹화한 통계를 사용하여 '전체 확진자', '전체 사망자', '백신접종완료자수'를 비율 막대로 표시하는 코드이다.  

```{r eval=FALSE}
df_covid19_stat |>
  filter(iso_code %in% c('OWID_HIC', 'OWID_LIC', 'OWID_LMC', 'OWID_UMC')) |>
  select(3, 6, 7, 14) |>
  pivot_longer(cols = c(2, 3, 4)) |>
  pivot_wider(names_from = location) |>
  group_by(name) |>
  mutate(sum = (`High income`+`Low income`+`Lower middle income`+`Upper middle income`)) |>
  mutate(`High income` = `High income` / sum, 
         `Low income` = `Low income` / sum, 
         `Lower middle income` = `Lower middle income` / sum, 
         `Upper middle income` = `Upper middle income` / sum) |>
  plot_ly(type = 'bar', x = ~`High income`, y = ~name, 
          orientation = 'h', name = 'High income',
          marker = list(line = list(color = 'white', 
                                    width = 2))
          ) |>
  add_trace(x = ~`Upper middle income`, name = 'Upper middle income') |>
  add_trace(x = ~`Lower middle income`, name = 'Lower middle income') |>
  add_trace(x = ~`Low income`, name = 'Low income') |>
  add_annotations(xref = 'x', yref = 'y',
                  x = ~`High income` / 2, y = ~name,
                  text = ~paste(round(`High income`*100, 1), '%'),
                  font = list(color = 'white'), 
                  showarrow = FALSE) |>
  add_annotations(xref = 'x', yref = 'y',
                  x = ~`High income` + `Upper middle income` / 2, y = ~name,
                  text = ~paste(round(`Upper middle income`*100, 1), '%'),
                  font = list(color = 'white'), 
                  showarrow = FALSE) |>
  add_annotations(xref = 'x', yref = 'y',
                  x = ~`High income` + `Upper middle income` + `Lower middle income` / 2, y = ~name,
                  text = ~paste(round(`Lower middle income`*100, 1), '%'),
                  font = list(color = 'white'), 
                  showarrow = FALSE) |>
  layout(barmode = 'stack', 
         title = '국가 소득급간별 코로나19 현황',
         xaxis = list(title = '', tickformat = '.0%'), 
         yaxis = list(title = ''), 
         legend = list(orientation = 'h', traceorder = 'normal'), 
         margin = margins) 

```
```{r echo=FALSE}
df_covid19_stat |>
  filter(iso_code %in% c('OWID_HIC', 'OWID_LIC', 'OWID_LMC', 'OWID_UMC')) |>
  select(3, 6, 7, 14) |>
  pivot_longer(cols = c(2, 3, 4)) |>
  pivot_wider(names_from = location) |>
  group_by(name) |>
  mutate(sum = (`High income`+`Low income`+`Lower middle income`+`Upper middle income`)) |>
  mutate(`High income` = `High income` / sum, 
         `Low income` = `Low income` / sum, 
         `Lower middle income` = `Lower middle income` / sum, 
         `Upper middle income` = `Upper middle income` / sum) |>
  plot_ly(type = 'bar', x = ~`High income`, y = ~name, orientation = 'h', name = 'High income',
        marker = list(color = RColorBrewer::brewer.pal(5, 'Blues')[5], 
          line = list(color = 'white', width = 2))) |>
#  add_trace(x = ~`High income`, name = 'High income') |>
  add_trace(x = ~`Upper middle income`, name = 'Upper middle income', 
             marker = list(color = RColorBrewer::brewer.pal(5, 'Blues')[4])) |>
  add_trace(x = ~`Lower middle income`, name = 'Lower middle income', 
             marker = list(color = RColorBrewer::brewer.pal(5, 'Blues')[3])) |>
  add_trace(x = ~`Low income`, name = 'Low income', 
             marker = list(color = RColorBrewer::brewer.pal(5, 'Blues')[2])) |>
  add_annotations(xref = 'x', yref = 'y',
                  x = ~`High income` / 2, y = ~name,
                  text = ~paste(round(`High income`*100, 1), '%'),
                  font = list(color = 'white'), 
                  showarrow = FALSE) |>
  add_annotations(xref = 'x', yref = 'y',
                  x = ~`High income` + `Upper middle income` / 2, y = ~name,
                  text = ~paste(round(`Upper middle income`*100, 1), '%'),
                  font = list(color = 'white'), 
                  showarrow = FALSE) |>
  add_annotations(xref = 'x', yref = 'y',
                  x = ~`High income` + `Upper middle income` + `Lower middle income` / 2, y = ~name,
                  text = ~paste(round(`Lower middle income`*100, 1), '%'),
                  font = list(color = 'white'), 
                  showarrow = FALSE) |>
  layout(barmode = 'stack', 
         title = '국가 소득급간별 코로나19 현황',
         xaxis = list(title = '', tickformat = '.0%'), 
         yaxis = list(title = ''), 
         legend = list(orientation = 'h', traceorder = 'normal'), 
         margin = margins) 

```

## sunburst

'sunburst'의 사전적 의미는 '햇살'이다. 햇살처럼 퍼저나가는 데이터를 표현하기 위해 사용되는 형태의 시각화이다. `plotly`에서 지원하는 선버스트 trace는 루트(root)에서 잎(leaf)까지 원의 방사형 바깥쪽으로 퍼져나가면서 계층화된 데이터를 시각화한다. 따라서 선버스트 trace를 그리기 위해서는 계층화된 데이터가 필요하다. 선버스트 trace의 각 섹터는 `labels`과 `parents`의 속성에서 설정하는데 `label`은 선버스트 trace에서 표시되는 섹터의 표시 라벨의 벡터가 설정되고 `parents`는 각 섹터의 부모 섹터를 가리키는 라벨을 설정한다. 만약 `parents`에 설정된 부모 섹터가 ''이면 가장 안쪽의 노드인 루트 노드가 된다. 

다음은 선버스트 trace를 위해 필요한 데이터의 전처리 과정이다. df_sunburst_cases 데이터프레임을 만들기 위해서 두 개의 데이터프레임을 `rbind()`로 붙여 하나의 데이터프레임으로 만들었다. 첫 번째 데이터프레임은 각 대륙별 전체 확진자수 데이터프레임이고 두 번째 데이터프레임은 각 대륙별로 전체 확진자수가 많은 5개 국가의 데이터프레임이다.   

```{r}
df_sunburst_cases <- rbind(
  ## 각 대륙별 전체 확진자수 데이터프레임
  df_covid19_stat |> 
  filter(iso_code %in% c('OWID_AFR', 'OWID_ASI', 'OWID_EUR', 'OWID_NAM', 'OWID_OCE', 'OWID_SAM')) |>
  select(continent, location, 전체확진자수),
  ## 전체 확진자가 많은 대륙별 5개국 데이터 프레임
  df_covid19_stat |> 
    filter(!is.na(continent)) |>
    group_by(continent) |> top_n(5, wt = 전체확진자수) |>
    select(continent, location, 전체확진자수)
)

head(df_sunburst_cases, 10)
```

전처리된 데이터프레임을 보면 대륙의 데이터를 나타내는 행에는 'continent' 열이 비어있다. 각 대륙의 확진자가 많은 5개국은 'continent' 열에 대륙 이름이 기록되었다. 따라서 `parents` 속성이 'continent'열로 설정되고 전체 섹터의 이름으로 설정되는 `label`은 'location'열로 설정되었다. 이들 섹터의 값은 전체 확진자 열로 설정된다. 

다음의 코드에서 추가적으로 설정된 속성이 `branchvalues`와 `insidetextorientation`이다. `branchvalues`는 `values`로 설정된 아이템의 합계 산출 방법을 설정한다. "total"로 설정하면 `values`의 아이템이 모든 하위 항목의 값으로 간주된다. 예를 들어 부모 섹터의 `values`가 50, 2개의 자식 섹터의 `values`가 각각 20라면 부모 섹터의 40%씩을 차지하게 된다. 반면 "remainer"는 부모 섹터와 자식 섹터에 해당하는 `values`를 모두 더해서 비율을 산출하게 된다. 앞의 예처럼 부모 섹터가 50, 2개의 자식 섹터가 각각 20이라면 20/(50+20+20)이므로 22%가 산출된다. 

```{r echo = FALSE}
fig1 <- plot_ly(
  labels = c("root", "level1-1", "level1-2"),
  parents = c("", "root", "root"),
  values = c(50, 20, 20),
  type = 'sunburst', textinfo = 'label+percent parent+percent entry', 
  branchvalues = 'reminder', 
  marker= list(colors = RColorBrewer::brewer.pal(3, 'Blues')),
  domain = list(x = c(0.51, 1), y = c(0, 1))
)

fig2 <- plot_ly(
  labels = c("root", "level1-1", "level1-2"),
  parents = c("", "root", "root"),
  values = c(50, 20, 20),
  type = 'sunburst',textinfo = 'label+percent parent+percent entry', 
  branchvalues = 'total', 
  domain = list(x = c(0, 0.49), y = c(0, 1))
)


subplot(fig1 |>
          add_annotations(x = 0.5, y = 1, xref = 'paper', yref = 'paper', 
                          xanchor = 'center', 
                          text = "branchvalues = 'total'", showarrow = F), 
        fig2  |>
          add_annotations(x = 0.5, y = 1, xref = 'paper', yref = 'paper', 
                          xanchor = 'center', 
                          text = "branchvalues = 'reminder'", showarrow = F)
)
  


```

```{r eval = FALSE, message=FALSE, warning=FALSE, error=FALSE}
plot_ly() |>
  add_trace(type = 'sunburst',  
            labels = pull(df_sunburst_cases[2]), 
            parents = pull(df_sunburst_cases[1]), 
            values = pull(df_sunburst_cases[3]),
            branchvalues = 'total', 
            insidetextorientation='radial', 
            textinfo = 'label+percent parent+percent entry', 
            texttemplate = '국가:%{label}<br>전체의 %{percentParent}<br>%{parent}대륙의%{percentEntry}'
            )
```

```{r echo = FALSE, message=FALSE, warning=FALSE, error=FALSE}
plot_ly() |>
  add_trace(type = 'sunburst',  
            labels = pull(df_sunburst_cases[2]), 
            parents = pull(df_sunburst_cases[1]), 
            values = pull(df_sunburst_cases[3]),
            branchvalues = 'total', 
            insidetextorientation='radial', 
            marker = list(colors = RColorBrewer::brewer.pal(5, 'Blues')), 
            textinfo = 'label+percent parent+percent entry', 
            texttemplate = '국가:%{label}<br>전체의 %{percentParent}<br>%{parent}대륙의%{percentEntry}'
            )
```

# 데이터는 이렇게 흘러갑니다. - 산키 다이어그램

------------------------------------------------------------------------

산키 다이어그램은 두개 혹은 두개 이상의 변수간의 데이터 흐름을 잘 보여주는 다이어그램이다. 각각의 변수 항목의 변량들은 왼쪽과 오른쪽에 네모 박스로 표현하고 변량들의 데이터가 연관된 항목간의 데이터 량에 따라 굵기가 다른 선으로 이어지는 형태로 표현되는 다이어그램으로 비교적 최근부터 사용되기 시작한 그래프 형태이다.

최근 `plotly`에서 제공하는 trace에 `sankey`를 제공하기 때문에 추가적인 패키지의 도움없이 산키 다이어그램을 만들수 있지만 `ggplot2`의 경우는 확장 패키지로 만들어진 `ggsankey` 패키지를 통해 `ggplot` 객체의 산키 다이어그램을 만들 수 있다. 이외에도 `networkD3` 패키지를 사용할 수 있다.


산키 다이어그램을 생성하기 위해서는 세가지 데이터가 필요하다.

첫번째는 (네모 박스로 표현되는) 각각 노드의 이름, 두번째는 각각의 노드들이 연결되는 링크에 대한 정보, 세번째는 링크의 굵기가 표현될 데이터 정보이다.

이번 절에서 만들어 볼 산키 다이어그램은 취업통계 데이터를 사용하여 대학 과정(전문대학과정, 대학과정, 대학원과정)에 따른 졸업자가 졸업 후 어떤 진로를 선택했는지(취업, 진학 등)의 흐름을 연결하는 다이어그램이다. 이 산키 다이어그램을 생성하기 위해서는 앞서 설명한 세가지 데이터를 만들기 위해 다음과 같이 전처리하였다.

```{r}
df_sankey <- df_취업률 |> 
  ## 열 중에서 3열(과정구분, 왼쪽 노드로 사용)과 12열, 21열부터 26열(오른쪽 노드로 사용)까지를 선택
  select(3, 12, 21:26) |> 
  ## 과정구분 열을 사용하여 그룹화
  group_by(과정구분) |>
  ## 전체 열에 대해 `sum`을 적용(summarise_all은 전체 열에 동일한 요약함수를 적영하는 함수임)
  summarise_all(sum) |>
  ## 열이름을 적절히 변경
  rename(c('취업' = '취업자수', '진학' = '진학자_계', '취업불가' = '취업불가능자_계', '외국인' = '외국인유학생_계', '제외인정' = '제외인정자_계', '기타' = '기타_계', '미상' = '미상_계')) |>
  ##  첫번째 열을 제외하고 나머지 열들에 긴 형태의 데이터로 변환, 열 이름이 들어간 열은 '구분'으로 데이터 값이 들어간 열은 '학생수'열로 설정
  pivot_longer(cols = 2:8, names_to = '졸업구분', values_to = '학생수') |>
  ## 과정구분 열과 구분 열의 순서설정을 위해 팩터 레벨 설정
  mutate(과정구분_node = case_when(
    과정구분 == '전문대학과정' ~ 0, 
    과정구분 == '대학과정' ~ 1,
    과정구분 == '대학원과정' ~ 2),
    졸업구분_node = case_when(
      졸업구분 == '취업' ~ 3, 
      졸업구분 == '진학' ~ 4, 
      졸업구분 == '취업불가' ~ 5, 
      졸업구분 == '외국인' ~ 6, 
      졸업구분 == '제외인정' ~ 7, 
      졸업구분 == '기타' ~ 8, 
      졸업구분 == '미상' ~ 9)
    ) |>
  arrange(과정구분_node, 졸업구분_node)

head(df_sankey, 10)
```

이 데이터에서 뜻하는 것은 '과정구분'(전문대학, 대학, 대학원)의 졸업자가 '졸업구분'(취업, 진학 등)으로 몇 명이 배출되었는지를 한 행에 나타낸다. 예를 들어 첫 번쨰 행의 경우 전문대학과정 졸업자 중에 취업으로 간 학생은 105904명이라는 의미이다.  

이 데이터에서 앞서 설명한 세가지 데이터 벡터를 생성한다.

첫 번째 벡터는 노드의 이름을 가지는 벡터이다. 노드의 이름은 '과정구분' 열과 '졸업구분' 열의 각각의 변량을 벡터로 만들었다. 

```{r}
## 왼쪽 노드로 사용할 변량을 from에 저장
from <- unique(as.character(df_sankey$과정구분))

## 오른쪽 노드로 사용할 변량을 to에 저장
to <- unique(as.character(df_sankey$졸업구분))

## 전체 노드 벡터 생성
node <- c(from, to)

node
```

두번째로는 노드 링크 정보를 생성한다. 노드 링크 정보는 앞서 전처리한 df_sankey에서 '과정구분' 열에서 '졸업구분'열로 이동하는 의미로 구성하였고 각각의 노드에 대한 번호를 만들었 때문에 'source'를 '과정구분_node' 열 벡터로, 'target'을 '졸업구분_node' 열로 설정한다. 

여기서 중요한 것이 R에서 사용하는 인덱스는 일반적으로 1부터 시작하지만 여기서 사용하는 인덱스는 0부터 시작한다는 것이다.

세번쨰로 노드 데이터 정보를 생성한다. 앞서 데이터를 선처리 할 때 노드링크의 순서에 따라 데이터를 정리해 놓았기 때문에 df_sankey의 학생수 열을 사용할 수 있다.

이제 데이터의 전처리가 끝났으니 `plotly`의 `sankey` trace를 사용하여 산키 다이어그램을 생성한다. 

```{r fig.cap='산키 다이어그램'}
df_sankey |> plot_ly(
    type = "sankey",
    orientation = "h",

    node = list(
      label = node,
      color = c(rep('lightblue', 3), rep('darkblue', 7)),
      pad = 15,
      thickness = 20,
      line = list(
        color = "black",
        width = 0.5
      )
    ),

    link = list(
      source = ~과정구분_node,
      target = ~졸업구분_node,
      value =  ~학생수
    )
  ) |>
  layout(title = '대학과정별 졸업자의 졸업 후 진로', 
         margin = margins)


```


## radar

```{r}
df_radar_veccine <- df_covid19_stat |> 
  filter(iso_code %in% c('OWID_AFR', 'OWID_ASI', 'OWID_EUR', 'OWID_NAM', 'OWID_OCE', 'OWID_SAM')) |>
  select(continent, location, 백신접종완료률)

df_radar_deaths <- df_covid19_stat |> 
  filter(iso_code %in% c('OWID_AFR', 'OWID_ASI', 'OWID_EUR', 'OWID_NAM', 'OWID_OCE', 'OWID_SAM')) |>
  select(continent, location, 십만명당사망자수)

plot_ly() |>
  add_trace(type = 'scatterpolar',  
            theta = pull(df_radar_veccine[2]), 
            r = pull(df_radar_veccine[3]), 
            fill = 'toself'
            )

plot_ly() |>
  add_trace(type = 'scatterpolar',  
            theta = pull(df_radar_deaths[2]), 
            r = pull(df_radar_deaths[3]), 
            fill = 'toself'
            )


```

## 보고서는 네모야 - 트리맵

------------------------------------------------------------------------

대부분의 보고문서들은 네모난 종이위에 표현되거나 네모난 화면위에 표현된다. 앞서 기술한 파이 차트나 도넛 차트는 원형으로 표현되기 떄문에 네모난 종이나 화면에 표현하면 시각화에 사용되지 못하는 공간이 많아져서 전체 영역을 호과적으로 사용하지 못한다. 이러한 단점을 극복하기 위해 네모난 사각형을 사용하여 전체의 비율을 표현한 시각화 방법이 트리맵이다. 

```{r eval = FALSE}
plot_ly() |>
  add_trace(type = 'treemap',  
            labels = pull(df_sunburst_cases[2]), 
            parents = pull(df_sunburst_cases[1]), 
            values = pull(df_sunburst_cases[3]),
            textinfo = 'label+value+percent parent+percent entry'
            )
```


```{r echo = FALSE}
plot_ly() |>
  add_trace(type = 'treemap',  
            labels = pull(df_sunburst_cases[2]), 
            parents = pull(df_sunburst_cases[1]), 
            values = pull(df_sunburst_cases[3]),
            marker = list(colors = RColorBrewer::brewer.pal(5, 'Blues')), 
            textinfo = 'label+value+percent parent+percent entry'
            )
```


## 수학의 정석에 있던거였는데? – 벤 다이어그램

------------------------------------------------------------------------

벤다이어그램은 아마도 중학교 시절 한번식은 그려본 차트일 것이다. 사실 이 차트는 지금까지 줄기차게 설명했던 데이터의 시각화와는 좀 다른 형태의 시각화이다. 우선 데이터의 양에 직접적인 관계가 없고 데이터의 성질에 관계가 있다는 점에서 정량적 시각화가 아닌 정성적 시각화이다. 각 데이터의 크기를 비교하는 것이 아닌 데이터간의 관계를 표현한다는 점도 다른 시각화와 매우 다르다. 하지만 데이터의 전반적 구조를 표현하거나 데이터 분석을 통해 도출된 인사이트를 전달하는 과정에서 효과적으로 사용될 수 있는 시각화이다.

R의 많은 사용자들은 데이터와 직접적 관계가 없는 벤다이어그램을 R에서 그린다는게 어색할 것이다. 보통 이렇게 데이터와 직접적 관계가 없는 시각화는 파워포인트와 같은 프리젠테이션 전용 툴이나 일러스트레이터와 같은 전문 그래픽 툴을 사용하는 것이 일반적이다. 하지만 R 마크다운을 사용하여 R에서 직접적으로 문서를 만들거나 그래픽 툴에 익숙하지 않은 데이터 분석가들을 위해 R에서 벤다이어그램을 그릴 수 있도는 패키지가 제공되고 있다.

R에서 벤다이어그램을 만들 수 있도록 제공되는 패키지는 `ggVennDiagram` 패키지이다.[^1] 이 패키지에서 제공하는 `ggVennDiagram()`을 이용해서 벤다이어그램을 만들 수 있다.

[^1]: 이 패키지외에 `VennDiagram` 패키지도 있지만 `VennDiagram` 패키지에서는 한글을 지원하지 못한다는 결정적 단점이 있다.

### 기본 벤다이어그램

벤다이어그램을 그리기 위해서는 먼저 `ggVennDiagram`패키지를 설치한다.

```{r}
## ggVennDiagram 설치
if(!require(ggVennDiagram)) {
  install.packages('ggVennDiagram')
  library(ggVennDiagram)
}
```

`ggVennDiagram` 패키지에서 제공하는 `ggVennDiagram()`의 사용법은 다음과 같다.

::: {custom-style="comment"}
ggVennDiagram(x, category.names = names(x), show_intersect = FALSE, set_color = "black", set_size = NA, label = c("both", "count", "percent", "none"), label_alpha = 0.5, label_geom = c("label", "text"), label_color = "black", label_size = NA,  label_percent_digit = 0, label_txtWidth = 40, edge_lty = "solid", edge_size = 1,  ...)  
  - x : 벤다이어그램에 사용 할 벡터 리스트  
  - category.names : 각각의 원에 해당하는 카테고리의 이름 설정  
  - show_intersect : 인터랙티브 플롯(plotly)으로 생성할지 여부를 결정하는 논리값  
  - set_color : 벤다이어그램 안의 텍스트 라벨 색 설정  
  - set_size : 벤다이어그램 안의 텍스트 라벨 크기 설정  
  - label : 텍스트 라벨의 표시 형태 설정, "both", "count", "percent", "none" 중에 하나 설정  
  - label_alpha : 벤다이어그램 안의 텍스트 라벨 투명도 설정  
  - label_geom : 벤다이어그램 안의 텍스트 기하요소 설정, "label", "text" 중에 하나 설정  
  - label_color : 벤다이어그램 안의 텍스트 색 설정  
  - label_size : 벤다이어그램 안의 라벨 크기 설정  
  - label_percent_digit : 라벨 타입이 'percent'일 경우 소수점 아래 몇자리까지 출력할지 설정  
  - label_txtWidth : 벤다이어그램 교차부분의 텍스트 너비 설정  
  - edge_lty : 벤다이어그램 가장자리 라인 타입 설정  
  - edge_size : 벤다이어그램 가장자리 라인 굵기 설정  

:::

벤다이어그램은 보통 3개의 원으로 표현되는 것이 효율적이다. 그 이상의 원으로 표현은 가능하겠지만 오히려 데이터의 특징을 전반적으로 확인하는데 방해되는 경우도 많다.

벤다이어그램을 그리기 위해서는 먼저 벤다이어그램에 사용할 데이터 벡터를 생성해야 한다. 여기서는 공학계열의 학과들을 과정구분별로 필터링해서 세개의 벡터를 생성하고 이에 대한 벤다이어그램을 그리도록 한다.

```{r}
## 전문대학과정의 공학계열 학과명을 벡터로 저장
vec_전문대학과명 <- df_취업률 |> 
  filter(대계열 == '공학계열', 과정구분 == '전문대학과정') |>
  select(학과명) |> 
  ## 하나의 열만 선택하더라도 여전히 데이터프레임이기 때문에 pull()로 벡터화
  pull()

## 대학과정의 공학계열 학과명을 벡터로 저장
vec_대학학과명 <- df_취업률 |> 
  filter(대계열 == '공학계열', 과정구분 == '대학과정') |>
  select(학과명) |> 
  pull()

## 대학원과정의 공학계열 학과명을 벡터로 저장
vec_대학원학과명 <- df_취업률 |> 
  filter(대계열 == '공학계열', 과정구분 == '대학원과정') |>
  select(학과명) |> 
  pull()

## 벤다이어그램의 제목 설정과 데이터를 연결한 리스트 생성
list_venn_diagram <- list(전문대학 = vec_전문대학과명, 대학 = vec_대학학과명, 대학원 = vec_대학원학과명)
```

```{r fig.cap='기본 벤다이어그램'}
## 벤다이어그램 생성
ggVennDiagram(list_venn_diagram)
```

### 벤다어그램 색 바꾸기

`ggVenDiagram()`은 `ggplot`의 기본 컨셉을 사용하기 때문에 색을 바꾸는 것은 `scale_fill_*()`을 사용할 수 있다. 다음은 흰색부터 하늘색까지의 그라디언트를 사용한 벤다이어그램이다. 추가적으로 범례를 제거하고 제목을 설정하였다.

```{r fig.cap='벤다이어그램 꾸미기'}
## 벤다이어그램 생성
ggVennDiagram(list_venn_diagram) + 
  ## fill 스케일을 'white'부터 'skyblue'까지인 그라디언트로 설정하고 범례는 제거
  scale_fill_gradient(low = "white", high = "skyblue", guide = FALSE) + 
  ## color 스케일을 사용자 정의형으로 설정하고 범례는 제거
  scale_color_manual(values = c('전문대학' = 'grey', '대학' = 'grey', '대학원' = 'grey'), guide = FALSE) +
#  theme(legend.position = "none") + 
  labs(title = '공학계열 학과의 분포') + 
  theme(plot.title = element_text(hjust = 0.5))
```

### 3개이상 값에 대한 벤다이어그램

보통 벤다이어그램은 원 3개를 사용하는 것이 대부분이다. 하지만 `ggVennDiagram` 패키지에서는 7개까지의 값에 대한 벤다이어그램을 지원한다. 다음은 변수에 수에 다른 벤다이어그램의 형태를 보이고 있다.

```{r echo=FALSE}
plot_shapes()
```

앞서 그려보았던 벤다이어그램의 대학원을 석사와 박사로 나눠 네개의 변량에 대한 벤다이어그램은 다음과 같이 생성할 수 있다.

```{r}
## 석사과정의 공학계열 학과명을 벡터로 저장
vec_석사학과명 <- df_취업률 |> 
  filter(대계열 == '공학계열', 과정구분 == '대학원과정', 학위구분 == '석사') |>
  select(학과명) |> 
  pull()

## 박사과정의 공학계열 학과명을 벡터로 저장
vec_박사학과명 <- df_취업률 |> 
  filter(대계열 == '공학계열', 과정구분 == '대학원과정', 학위구분 == '박사') |>
  select(학과명) |> 
  pull()

## 벤다이어그램의 제목 설정과 데이터를 연결한 리스트 생성
list_venn_diagram1 <- list(전문대학 = vec_전문대학과명, 대학 = vec_대학학과명, 석사 = vec_석사학과명, 박사 = vec_박사학과명)
```

```{r fig.cap='4개의 변량 벤다이어그램'}
ggVennDiagram(list_venn_diagram1)

```


## 여러 종류이 널리 퍼져있는 데이터는? - 업셋 그래프

------------------------------------------------------------------------

중복이 허용되면서 변량이 많지 않은 데이터를 시각화하는 방법으로 많이 활용되는 것이 벤다이어그램이다. 벤다이어그램은 10장에서 설명하겠지만 원으로 변량을 표현해 중복에 대한 표현이 가능한 장점이 있다. 하지만 원(변량)이 3개를 넘어가면 매우 혼란스러워진다. 이 벤다이어그램의 단점을 극복하기 위해 2014년에 제안된 시각화 방법이 업셋 그래프이다.[^4]

[^4]: [Alexander Lex](https://vdl.sci.utah.edu/team/lex/), [Nils Gehlenborg](http://www.gehlenborg.com/), [Hendrik Strobelt](http://hendrik.strobelt.com/), Romain Vuillemot, [Hanspeter Pfister](http://vcg.seas.harvard.edu/people/hanspeter-pfister)\
    [**UpSet: Visualization of Intersecting Sets**](https://sci.utah.edu/~vdl/papers/2014_infovis_upset.pdf)\
    IEEE Transactions on Visualization and Computer Graphics (InfoVis), 20(12): 1983--1992, [doi:10.1109/TVCG.2014.2346248](http://dx.doi.org/10.1109/TVCG.2014.2346248), 2014.

업셋 그래프는 그래프의 아래쪽에 해당 데이터를 구성하는 세트의 조합이 표현되고 위쪽에는 해당 세트의 조합에 대한 데이터 값을 표현하는 막대 그래프가 표현된다. 이렇게 구성함으로써 단일 세트만 가능했던 막대 그래프에 변량의 세트에 대한 표현이 가능해져서 벤다이어그램에서 해석이 어려웠던 다양한 데이터의 조합에 대한 시각화에 매우 효과적이다.

업셋 그래프는 3개 이상 30개 미만의 집합 데이터에 가장 적합하다 . 4세트 미만의 경우 익숙한 벤 다이어그램이 친숙하다. 또 업셋 그래프는 집합 데이터의 분포를 분석하는 데 적합하기때문에 교차하는 집합의 조합의 빈도확인에 매우 효과적이다.[^5]

[^5]: <https://upset.app/>

그럼 이제 업셋 그래프를 만들어 보겠다. df_취업통계 데이터는 각 학과를 7개의 학제(전문대학(2년제), 전문대학(3년제), 대학교, 산업대학 등)로 구분되어 있다. 따라서 같은 학과명을 가지더라도 서로 학제가 달라 최대 7개의 행이 있을 수 있다. 그래서 동일한 학과명이 여러 학제에 걸쳐 존재하는 경우가 많은데 이 분포를 알아내기 위해 업셋 그래프를 만든다. 

이 업셋 그래프를 만들기 위해 사용하는 데이터는 이 df_취업통계 데이터로 각각의 학과명이 속한 학제를 리스트로 만든 열이 필요하다. 이 열을 기준으로 빈도를 표현한 막대 그래프를 그릴 것이다. 이를 위해 다음과 같이 데이터를 전처리 한다. 

```{r}
## df_취업통계에서
df_과정구분_upset <- df_취업률 |>
  ## 학과명으로 그룹화
  group_by(학과명) |>
  ## 학제를 리스트로 만든 학과리스트 열을 생성(각각의 그룹의 행에 학과리스트 열은 모두 같은 값을 가지기 때문에 맨 아래에서 중복을 제거)
  mutate(학제리스트 = list(unique(sort(학제)))) |>
  ## 필요한 열만 선택
  select(3:6, 8, 학제리스트, 11) |>
  ## 중복을 제거
  unique()
```

```{r eval = FALSE}
## df_과정구분_upset |> View() 로 데이터를 확인 가능
View(df_과정구분_upset)  ## 'V'는 대문자임에 주의
```

전처리가 끝났으면 본격적으로 업셋 그래프를 만든다. 이를 위해 먼저 `ggupset` 패키지를 설치해야한다. 

```{r}
## ggupset 패키지 설치
if(!require(ggupset)) {
  install.packages('ggupset')
  library(ggupset)
}

```

업셋 그래프를 그리는 코드는 다음과 같다. 먼저 학과명의 조합 리스트로 구성된 학과명을 X축으로 매핑한 geom_bar 레이어를 생성한다. 이후 X축의 스케일를 업셋  스케일로 바꾸어주면 업셋의 기본 그래프가 생성된다. 축의 스케일을 업셋 스케일로 바꾸려면 `scale_x_upset()`을 사용한다.

::: {custom-style="comment"}
scale_x_upset(order_by = c("freq", "degree"), n_sets = Inf, n_intersections = Inf, sets = NULL, intersections = NULL, reverse = FALSE, ytrans = "identity", ..., position = "bottom")  
  - order_by : X축의 순서 설정을 어떻게 할지 설정  
  - n_sets : 전체 셋의 최대값 설정  
  - n_intersections : 표시될 교차 셋의 최대값 설정  
  - sets : 표시하고 싶은 셋의 이름 벡터 설정  
  - intersections : 표시될 교차 셋의 이름 벡터 설정  
  - reverse : 교차값의 역순으로 설정할 논리값 설정  
  - ytrans : Y축의 변환 설정  
  - ... : 이산형 스케일과 관련한 추가 매개변수  
  - position : X축을 아래에 위치할 것인지 위에 위치할 것인지 설정  

:::

빈도수를 표현하는 `geom_bar()`의 X축 스케일을 `scale_x_upset()`으로 설정하여 업셋 그래프를 그리는 코드는 다음과 같다. 

```{r fig.cap='기본 업셋 그래프'}
df_과정구분_upset |> ggplot() +
  ## X축을 학제리스트로 매핑한 geom_bar 레이어 생성
  geom_bar(aes(x=학제리스트)) +
  ## X축 스케일을 업셋 스케일로 설정
  scale_x_upset()

```

7개의 학제에 대한 조합이 표현되다보니 조합의 수가 너무 많아 보인다. 이 중 빈도가 많은 10개의 조합만 표시하도록하는 코드는 다음과 같다. 

```{r fig.cap='기본 업셋 그래프'}
ggplot(df_과정구분_upset, aes(x=학제리스트)) +
  geom_bar() +
  ## n_intersection을 10으로 설정해서 X축 변량을 10개로 한정
  scale_x_upset(n_intersections = 10)


```

앞의 그래프를 보면 대학교에만 존재하는 학과가 가장 많고 다음은 일반대학원이다. 세번째로 많은 분포는 대학교와 일반대학원에 같이 존재하는 학과가 있다는 것을 알 수 있다. 


앞의 업셋 그래프의 조합 매트릭스의 조합이 많은 순으로 정렬 순서를 바꾸면 다음과 같이 바꿀 수 있다. 

```{r fig.cap='조합순으로 정렬된 업셋 그래프'}
df_과정구분_upset |>
  ggplot() +
  geom_bar(aes(x=학제리스트), fill = "dodgerblue") +
  geom_text(aes(x=학제리스트, label = ..count..), stat = 'count', vjust = -1, size = 3, color = "darkblue") +
  ## order_by를 'degree'로 설정하여 매트릭스 조합을 정렬 기준으로 맞추고 내림차순으로 설정하기 위해 reverse를 설정
  scale_x_upset(n_intersections = 10,  
                order_by="degree", 
                reverse = TRUE) +
  ylab("학과수") + xlab("학제 조합")

```

업셋 그래프에 사용되는 상위 그래프는 막대 그래프외에 모든 그래프를 사용할 수 있다. 다만 X축의 조합 매트릭스를 설정함으로써 데이터를 잘 설명할 수 있는지 고려하여 설정하는 것이 좋다. 다음은 앞의 빈도수의 막대 그래프를 취업률에 대한 바이올린 그래프로 바꾼 코드이다. 

```{r fig.cap='바이올린 업셋 그래프'}
df_과정구분_upset |> 
  ggplot() +
  ## 상부 그래프의 레이어를 geom_violin 레이어로 생성
  geom_violin(aes(x=학제리스트, y = 취업률), fill = "darkblue") +
  scale_x_upset(n_intersections = 10,  order_by="degree", reverse = TRUE) +
  ylab("취업률") + xlab("학제 조합")

```
